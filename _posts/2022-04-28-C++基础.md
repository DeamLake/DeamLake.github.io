---
title: C++基础
tags: C++
article_header:
  type: cover
  image:
    src: /assets/images/drogan.jpg
---

C++ 基础知识点

<!--more-->

---
# C++中类成员的访问权限和继承权限问题

1. 三种访问权限
* public：公有成员类内类外都可以访问
* private：私有成员类内可以访问，类外是隐藏状态
* protected：保护成员类内可以访问，类外是隐藏状态，在派生类中可以访问
2. 三种继承方式
* public：访问权限不变
* private：全都变成私有
* protected：私有还是私有，公有和保护全都变保护

# cout和printf的区别

cout会先将输出字符放到缓冲区，然后输出到屏幕，是有缓冲输出

printf直接输出到屏幕，是无缓冲输出

# 定义和声明的区别

声明只说明其存在，不分配内存

定义才会分配内存

# 全局变量和static全局变量的区别

两者都是静态存储方式

* 非静态全局变量的作用域是整个源程序
* static全局变量的作用域只在定义该变量的源文件内
* static函数的作用域和static变量类似，static说明此函数只在当前文件内有作用


# ifdef endif代表什么

选择性编译程序段

# ++it和it++哪个好

it++会产生临时对象

++it则直接返回引用

# 在成员函数中调用delete this会有什么问题

类对象的内存空间中，只有数据成员和虚函数表指针，不包含代码内容。

delete this之后，只要不涉及this指针的内容（上一行的东西），就能够正常运行。

如果在析构函数中调用delete this，因为delete this本身会调用析构函数，因此会造成无限递归调用，最终造成堆栈溢出。

# 不使用额外空间交换两个数

算数

```c++
x=x+y; //求和
y=x-y; //获取x
x=x-y; // 获取y
```
异或
```c++
x = x^y; // 抵消相同的1 不同的1合并
y = x^y; // 抵消xy不同的1中y的部分 获取相同的部分 变为x
x = x^y; // 和第二行同理  变为y
```

# volatile关键字

变量可能被操作系统、硬件或者其他线程修改

编译起对访问该变量的代码不再优化   系统总是重新从它所在的内存读取数据

用于提供对特殊地址的稳定访问   

使用场景 ：

*  中断服务程序中修改的供其它程序检测的变量需要加volatile
*  多任务环境下各任务间共享的标志应该加volatile
*  存储器映射的硬件寄存器通常也要加volatile说明，每次对它的读写都可能有不同含义

# 空类添加的函数

```c++
1)  Empty(); // 缺省构造函数//

2)  Empty( const Empty& ); // 拷贝构造函数//

3)  ~Empty(); // 析构函数//

4)  Empty& operator=( const Empty& ); // 赋值运算符//
```
 
# const char* 和 string 之间的关系

```c++
a)  string转const char* 

string s = “abc”; 

const char* c_s = s.c_str(); 

b)  const char* 转string，直接赋值即可 

const char* c_s = “abc”; 
 string s(c_s); 

c)  string 转char* 
 string s = “abc”; 
 char* c; 
 const int len = s.length(); 
 c = new char[len+1]; 
 strcpy(c,s.c_str()); 

d)  char* 转string 
 char* c = “abc”; 
 string s(c); 

e)  const char* 转char* 
 const char* cpc = “abc”; 
 char* pc = new char[strlen(cpc)+1]; 
 strcpy(pc,cpc);

f)  char* 转const char*，直接赋值即可 
 char* pc = “abc”; 
 const char* cpc = pc;
```
 
# 什么时候用指针当参数，什么时候用引用

内置类型直接传值

数组用指针

其他都用引用

# 静态绑定和动态绑定

静态类型是对象在声明时采用的类型，在编译期确定

动态类型是对象所指的类型，在运行期确定，可以更改

# 什么时候合成构造函数、拷贝构造函数

深度探索C++对象模型-构造函数语义学

# 成员初始化列表会在什么时候用到？它的调用过程是什么？

* 当初始化一个引用成员变量时；
* 初始化一个const成员变量时；
* 当调用一个基类的构造函数，而构造函数拥有一组参数时；
* 当调用一个成员类的构造函数，而他拥有一组参数；
* list中的项目顺序是由类中的成员声明顺序决定的，并在显式用户代码前。

# 构造函数的执行顺序

1. 虚基类、父类的构造函数调用
2. 初始化vptr
3. 成员初始化列表
4. 显式用户代码

# 构造函数扩展过程

* 成员初始化列表的初始化操作被放到构造函数体内
* 如果成员没在初始化列表中，但是它有默认构造函数，则调用其构造函数
* 为虚表设定初值
* 调用父类构造函数
* 虚基类的构造函数

# 哪些函数不能为虚函数

* 构造函数：虚函数用虚表指针进行调用，但虚表指针需要在构造函数中进行初始化
* 内联函数：内联函数表示在编译阶段进行函数体替换操作，但虚函数需要在运行期进行确定
* 静态函数：静态函数不属于对象，意味着它没有对象特有的虚表指针，无法进行虚函数调用
* 友元函数：友元函数不属于类的成员函数，无法被继承
* 普通函数：不属于类

# strcpy、sprintf、memcpy三者的区别

1. 操作对象不同
* strcpy的两个对象均为字符串
* sprintf的源对象可以是多种数据类型，目标对象是字符串
* memcpy的两个对象是任意可操作的地址
2. 执行效率不同
memcpy最高，strcpy次之，sprintf效率最低

3. 实现功能不同
* strcpy主要实现字符串变量的拷贝
* sprintf主要实现其他数据类型格式到字符串的转化
* memcpy主要是内存块间的拷贝

# 阻止类被实例化的方法

定义类为抽象类

将构造函数设为private或者=delete

# 回调函数

* 当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数；
* 回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。为此，你需要做三件事：1，声明；2，定义；3，设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用；
* 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用它所指向的函数时，我们就说这是回调函数；
* 因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。

# 一致性哈希

自己查

# C++从代码到可执行程序经历了什么？

* 预编译
1. 删除所有#define，展开所有宏定义
2. 处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”
3. 处理“#include”预编译指令，将文件内容替换到它的位置
4. 删除所有注释
5. 保留所有的#pragma 编译器指令
6. 添加行号和文件标识，便于编译时编译器产生调试信息，和编译时产生编译错误或警告
* 编译
1. 把预编译之后生成的xxx.i或xxx.ii文件
2. 进行词法分析、语法分析、语义分析
3. 源代码级别优化
4. 生成汇编语言表示的目标代码
5. 目标代码优化
* 汇编
把汇编代码转换成机器可以执行的指令

* 链接
将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链

* 静态链接
将自身和静态库中所有用到的函数和数据组合起来，创建最终的可执行文件。

会产生空间浪费的问题；且更新困难，有代码改动就需要重新编译

但执行速度快

* 动态链接
把程序按照模块拆分成各个相对独立部分

在程序运行时才将它们链接在一起形成一个完整的程序

程序之间依赖共享库

更新方便但会有性能损耗

# 几种典型的锁

* 读写锁
* 互斥锁
* 条件变量
* 自旋锁




